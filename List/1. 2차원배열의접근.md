# 2차원 배열의 순회

- 행 우선 순회, 열 우선 순회, 지그재그 순회 등이 있다. 여기서 지그재그 순회가 다시 공부할 때 잘 이해가 안되었음.

### Q1. 지그재그 순회가 뭘까?

- 지그재그 순회

```python
for i in range(len(Array)):
    for j in range(len(Array[0])):
        Array[i][j+(m-1-2*j) * (i % 2)] #n = 행의 길이, m = 열의 길이
        #j를 한번 빼주고 m-1에서 j를 한번 더 빼주는 방법이다. 짝수번째에서는 Array[i][j]가 된다.
        #필요한 연산 수행
```

천천히 생각해보니 알 것 같다. 홀수번째에 오른쪽에서 왼쪽으로 순회하게 만들려면, j가 0에서 열의 길이만큼까지 움직이므로 열의 길이-j를 표현하면 오른쪽에서 왼쪽으로 이동하는 순회를 만들 수 있을 것이라 생각할 수 있다. 여기에서 인덱스만 맞춰 준 것이 위의 식이다!



(m-1) -> 열의 길이 len(Array[0])에서 1을 뺀 것. 1을 뺀 이유는 인덱스값이기 때문에 0부터 시작해서!

따라서 홀수번째 행일 때 식은,

`Array[i][m-1-j]`로 표현된다!!



### Q2. 델타를 이용한 2차 배열 탐색

- 델타를 이용하여 2차 배열을 탐색하는 방법은 배우고 쓸 때는 문제가 없었지만 조금 시간이 지난 후 스스로 구현해보려고 하면 어려운 방법이라고 생각한다. 다시 한 번 복습하고, 문제까지 두 개 살펴보며 리마인드 해보자.
- 델타를 이용한 2차 배열 탐색을 달리 말하면, 내 위치를 기준으로 리스트를 탐색하는 방법! 으로 이해할 수 있겠다.
- 간단한 예시 코드를 살펴보자.

```python
arr = [[1, 2, 3],
      [4, 5, 6],
      [7, 8, 9]]
r = 1 #현재 위치 row, column
c = 1
#상하좌우
dr = [-1, 1, 0, 0]
dc = [0, 0, -1 ,1]
#상하좌우
drc = [[-1, 0], [1, 0], [0, -1], [0, 1]]
#둘 중 어떤걸 써도 상관없다.

for i in range(4):
    nr = r + dr[i]
    nc = c + dc[i]
    if 0<=nr<N and 0<=nc<N:
    #제한조건
    #-1일 경우 오류가 아니라 -1번째 행, 열의 값을 가져오는 것을 방지하기 위한 코드
        print(arr[nr][nc])
    # 2, 4, 8, 6 순으로 출력이 됨
```

위 코드는 시작점을 (1, 1)로 설정하고 상하좌우 순으로 값을 출력하는 예제이다.

천천히 읽어보면 어렵지 않게 이해할 수 있다. 어려운 부분은 응용이다. 델타를 응용하여 달팽이 문제를 어떻게 풀 수 있을까?

다음 md로 넘어가자.

