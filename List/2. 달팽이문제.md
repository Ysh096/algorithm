**Problem1. 달팽이 문제**

달팽이는 1부터 N*N까지의 숫자가 시계방향으로 이루어져 있다. 다음과 같이 정수 N을 입력 받아 N크기의 달팽이를 출력하시오.

예시)

N이 3일 경우

1	2	3

8	9	4

7	6	5



N이 4일 경우

1	   2	  3	  4

12	13	14	5

11	16	15	6

10	 9	   8     7

문제풀이전략: N*N 배열을 만들고, 우->하->좌->상->우->하... 순으로 숫자를 채워나간다.

그를 위해 배열의 끝에 도달하면 방향을 바꾸는 로직이 필요하다. 여기서 끝이란, 더 이상 배열이 없는 경우 혹은 이미 숫자가 채워져 있는 부분을 만난 경우라고 할 수 있다.

```python
T = int(input())
for tc in range(1, T+1):
    N = int(input())
    # matrix = [[0]*N]*N 이렇게 만들면 얕은복사여서 문제 발생
    matrix = []
    for _ in range(N):
        row_matrix = []
        for _ in range(N):
            row_matrix += [0]
        matrix += [row_matrix]
        
    matrix[0][0] = 1 #초기값
    #2N-1번의 방향 전환을 한다.
    #우->하->좌->상->우->하->...
    x = 0
    y = 0
    dx = [0, 1, 0, -1]*N #방향이 담긴 배열
    dy = [1, 0, -1, 0]*N #방향이 담긴 배열
    i = 0
    val = 2 #채워 넣을 숫자, 2 3 4 5 ... N
    while val <= N*N:
        nx = x+dx[i]
        ny = y+dy[i]
        if nx>=N or ny>=N or nx<0 or ny<0 or matrix[nx][ny]!=0:
        #nx, ny가 배열의 범위를 벗어나거나 이미 숫자가 채워져 있는 부분을 만난 경우
            i = i+1 #방향을 바꾼다.
            continue
        else:
            matrix[nx][ny] = val
            x, y = nx, ny
            val += 1
    print('#{}'.format(tc))
    for i in range(N):
        print(*matrix[i])
```



문제 풀이의 핵심은 dx, dy의 설정과 제한 조건 설정이라고 할 수 있다.

언제 방향을 바꿔야 하는가! 가 가장 중요하다.



**Problem2. 삼각 달팽이**

정수 n이 매개변수로 주어질 때, 밑변의 길이와 높이가 n인 삼각형에서 맨 위 꼭짓점부터 반시계 방향으로 달팽이 채우기를 진행한 후, 첫 행부터 마지막 행까지 모두 순서대로 합친 새로운 배열을 return 하도록 solution 함수를 완성하라.

​     n=4

​		1

​	 2	9

 3	10	8

4	5	6	7

출력 -> [1, 2, 9, 3, 10, 8, 4, 5, 6, 7]

​         n=5

​		 	1

​		 2	12

​	   3	13	11

​	4	14	15	10

  5 	 6	  7	  8	  9

출력 -> [1, 2, 12, 3, 13, 11, 4, 14, 15, 10, 5, 6, 7, 8, 9]



이 문제의 경우에는 움직임이 아래 -> 오른쪽 -> 위가 반복된다.

이때, 오른쪽 다음 위로 움직이는 경우에 인덱스가 행도 -1, 열도 -1이 됨을 파악한다면 쉽게 풀 수 있는 문제였다.

```python
def solution(n):
    matrix = []
    for i in range(1, n+1):
        matrix += [[0]*i] #삼각형 모양 배열 만들기
    x = 0
    y = 0
    val = 1
    #초기값
    dr = [1, 0, -1]*n #방향을 바꾸는 배열, 부족하지 않을 정도로 만들어놨음.
    dc = [0, 1, -1]*n
    k = 0
    while k < n:
        matrix[x][y] = val
        nr = x+dr[k]
        nc = y+dc[k]
        if nr > n-1 or nr < 0 or nc > n-1 or nc < 0 or matrix[nr][nc] != 0:
            k = k+1
            continue
        else:
            val += 1
            x = nr
            y = nc
    result = []
    for row in matrix:
        result += row
    return result
```

일단 처음에 nr > n-1 or nr <0과 nc > n-1과 nc < 0으로 범위에 제한이 걸리며 테두리를 돈 후에, /_ 모양이 완성되었으면, \ 모양에 이르러서는 1과 만나면 방향을 바꾸게 되고, 그 다음은 계속해서 배열에 이미 값이 차 있으면 방향을 바꾸게 된다.

그 외에는 사각형 달팽이 문제와 완전히 동일하다!





**정리**

달팽이 문제에서 필요로 하는 것!

1. 방향델타의 배열을 정확히 만들기

2. 초기 위치 설정
3. 방향을 바꾸는 조건 설정