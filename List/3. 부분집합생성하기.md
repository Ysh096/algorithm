# 부분집합?

집합의 원소가 n개일 때, 공집합을 포함한 부분집합의 수는 2^n개이다.

-> 각 원소를 부분집합에 포함시키거나 시키지 않는 두 가지 경우!



이걸 for문으로 쓰면, 다음과 같이 매우 비효율적인 코드가 작성된다.

```python
bit = [0, 0, 0, 0]
for i in range(2):
    bit[0] = i
    for j in range(2):
        bit[1] = j
        for k in range(2):
            bit[2] = k
            for l in range(2):
                bit[3] = l
            	print(*bit) #*는 언패킹 연산자, 리스트를 벗겨서 사용할 때..
#16가지 경우의 수가 모두 출력된다.
0 0 0 0
0 0 0 1
0 0 1 0
0 0 1 1
0 1 0 0
0 1 0 1
0 1 1 0
0 1 1 1
1 0 0 0
1 0 0 1
1 0 1 0
1 0 1 1
1 1 0 0
1 1 0 1
1 1 1 0
1 1 1 1
#위 경우의 수를 살펴보면 이진수와 같은 순서로 부분집합을 구성하고 있음을 알 수 있다.
```

위의 경우에서 16가지 경우의 수를 모두 살펴보면, 각 원소가 있고 없음이 마치 0부터 2^n까지의 이진수 표현과 같음을 알 수 있다.

여기에 다음의 두 가지 포인트를 접목하여 코드를 보다 간결하게 구성할 수 있다.

1. 1 << n 은 2^n과 같다. (shift 연산자)

2. i & 1 << j 는 i의 j번째 비트가 1인지 아닌지를 알려준다. (AND: 비트 단위로 and 연산)

   ex) i = 5, j = 2인 경우, 1 0 1 & 1 0 0 -> 1 0 0 (i의 2번째 비트가 1임)

   ex) i = 10, j = 2인 경우, 1 0 1 0 & 0 1 0 0 -> 0 0 0 0 (i의 2번째 비트가 1이 아님) 

```python
arr = [3, 6, 7, 1, 5, 4]

n = len(arr)

for i in range(1<<n):
    for j in range(n):
        if i & (1<<j):
            print(arr[j], end = ", ")
        print()
    print()
```

이제 위와 같이 써보면,

1. 우선 부분집합의 개수를 1<<n으로 표현하고(이건 2**len(arr)로 대체 가능..),

2. 각 경우가 0부터 63까지의 비트 표현에 따라 arr의 원소를 구성하는 것과 같을 것이므로

3. 0부터 63까지 i를 순회하며 각 경우에 0부터 n-1까지의 비트 자릿수를 확인해본다.

4. 결과적으로 i의 j번째 자릿수가 1인 경우에 그 위치의 원소가 출력될 것이다.

   ex) 1 0 1 0 0 1  -->  [3, 7, 4]

   ex) 0 1 1 1 0 0 --> [6, 7, 1]

