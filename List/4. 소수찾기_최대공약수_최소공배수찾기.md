# 소수 찾기

에라토스테네스의 체

여러 개의 소수를 찾아야 할 때 유용한 방법..

---

1부터 50까지의 수에서 소수를 찾는 법?

1. 1은 제외한다.
2. 2는 남기고, 2의 배수는 제거한다.
3. 3은 남기고, 3의 배수는 제거한다.
4. 이미 제거한 숫자는 건너뛰고, 5는 남기고 5의 배수는 제거한다.
5. 이런 식으로 계속 반복해준다.

##### 양현승님 코드

```python
def solution(n):
    answer = 0
    #에라토스테네스의 체
    memory = [1 for _ in range(n+1)] # n+1개의 원소를 갖는 배열을 만든다. (인덱싱을 위해 첫 번째 원소를 만들어준듯)
    # 2부터 n까지의 수를 순회합니다. 1은 무시!
    for p in range(2, n+1):
        # 나누어 떨어지는 수가 존재하면 다음 수로 점프합니다
        if memory[p] == 0:
            continue
        # p에 곱해나가는 수를 2부터 n이하까지 늘려나간다는 의미입니다.
        for q in range(2*p, n+1, p):
            memory[q] = 0
    # 전체를 다시 탐색하면서 메모리가 1인 인덱스만 카운트합니다.
    for i in range(2, n+1):
        if memory[i] == 1:
            answer += 1
    return answer
```



# 최대공약수, 최소공배수 찾기

최대공약수(Greatest Common Divisor)

gcd(a, b)

gcd(3, 12) = 3

gcd(32, 18) = 2

... 작은 수에서는 쉽게 구할 수 있지만, 숫자가 커진다면?



### 유클리드 호제법

---

gcd(A, B)        (조건: A > B, A != B) 에 대해서,

`A = qB + r (q는 몫, r은 나머지) 일 때, gcd(A, B) = gcd(B, r) 이다.`

이 식을 이용하면, 0 <= r < B < A 이므로 점점 작은 수에 대해 최대공약수를 구하게 되고, 그 속도가 생각보다 빠르다!

---

100 90

90 10

10 0 --> 10이 최대 공약수 (0의 약수는 모든 숫자, 10의 약수중 최댓값은 10)



11 47

47 11

11 3

3 2

2 1 

1 0 --> 1이 최대 공약수 (0의 약수는 모든 숫자, 1의 약수중 최댓값은 1)



최소공배수 = n*m//g = m의 서로소 * n의 서로소 * 최대공약수**2 // 최대공약수 =  최소공배수