# 백트래킹 / 부분집합 /  분할정복 / 퀵소트



 ## 1. 백트래킹

해를 찾는 도중에 막히면 되돌아가서 다시 해를 찾아가는 기법!

최적화 문제와 결정 문제를 해결할 수 있다.



결정 문제(decision): 문제의 조건을 만족하는 해가 존재하는지 여부를 판단하는 문제

- 미로 찾기, n-Queen문제, 부분 집합의 합 문제 등

미로 찾기의 경우, 스택에 지나온 경로를 모두 쌓은 후 더 이상 갈 수 없으면 pop을 하여 이전 경로로 돌아가는 방식으로 문제를 해결한다.



**백트래킹과 깊이우선탐색의 차이**

- 백트래킹은 유망하지 않은(답이 될 가능성이 없는) 경로는 확인하지 않는다.

   (가지치기, prunning)

- 경우의 수가 일반적으로는 크게 줄어든다.

- n-Queen 문제에서 명확하게 차이를 알 수 있다. 깊이 우선 탐색은 모든 경우의 수를 따져보지만, 백트래킹은 답이 될 수 없는 경우 무시하고 지나간다!



# 2. 부분집합

**원소의 합이 10인 부분집합 구하기**

```python
N = 10
arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] # 구하고자 하는 부분 집합
sel = [0] * N # a 리스트 (내가 해당 원소를 뽑았는지 체크하는 리스트)

def power_set(idx):
    # idx가 N과 같아 질 때
    if idx == N:
        result = []
        for i in range(N):
            if sel[i]:
                result.append(arr[i])
        if sum(result) == 10:
            print(result)
        return # 혹은 조건 분기

    # sel의 idx번째 자리를 1로 바꾸고
    # idx 자리의 원소를 뽑고 진행
    sel[idx] = 1
    power_set(idx+1)

    # idx 자리의 원소를 뽑지 않고 진행
    sel[idx] = 0
    # 더 수행 할 코드가 없으면 -> 이 함수를 호출한 곳으로 돌아가자!
    power_set(idx+1)

# 함수 호출의 시작
power_set(0)
```

코드만 봐서는 잘 와 닫지 않지만 실행 해보면 어떤 느낌인지는 알겠다. 

1 1 1 1 1 1 1 1 1 1 1

1 1 1 1 1 1 1 1 1 1 0

1 1 1 1 1 1 1 1 1 0 1

1 1 1 1 1 1 1 1 1 0 0

1 1 1 1 1 1 1 1 0 1 1

1 1 1 1 1 1 1 1 0 1 0

1 1 1 1 1 1 1 1 0 0 1

1 1 1 1 1 1 1 1 0 0 0

...

이런 식으로 진행된다.



# 3. 분할정복

잘만 쓴다면 프로그램 속도를 크게 향상시킬 수 있을 듯!



**일반적인 거듭제곱 구하기**

```python
def Power(Base, Exponent):
    if Base == 0:
        return 1
    result = 1
    for i in range(Exponent):
        result *= Base #단순히 밑을 지수만큼 곱해준다.
    return result
```

이 경우 시간복잡도가 O(n)이다.



분할 정복의 경우에는 이미 했던 계산을 다시 하지 않는 형태로 작성이 가능하다.

```python
C^n에서 n이 짝수인 경우: C^n = C^(n/2) * C^(n/2) 의 점화식으로 표현 가능
C^n에서 n이 홀수인 경우: C^n = C^((n-1)/2) * C^((n-1)/2) * C 의 점화식으로 표현 가능
```

```python
def Power(Base, Exponent):
    if Exponent == 0 or Base == 0:
        return 1
    if Exponent % 2 == 0: # 지수가 짝수면
        NewBase = Power(Base, Exponent/2) # 재귀적 표현
        return NewBase * NewBase
   	else:
        NewBase = Power(Base, (Exponent-1)/2)
        return (NewBase * NewBase) * Base
```

이 경우 계산량이 매번 반씩 줄어들어 O(logn)의 시간 복잡도를 가지게 된다.



# 4. 퀵소트

주어진 배열을 두 개로 분할하여 각각 정렬!

- 합병정렬은 그냥 두 부분으로 나누는 반면에, 퀵정렬은 분할할 때, 기준 아이템 중심으로 이보다 작은 것은 왼편, 큰 것은 오른편에 위치시킨다.
- 각 부분 정렬이 끝난 후 합병정렬은 합병이라는 후처리 작업이 필요하나, 퀵 정렬은 필요하지 않다.

- 피봇을 가운데에 만들어놓고, left는 피봇보다 크거나 같은 값을 찾아 오른쪽으로 이동하고, right는 피봇보다 작은 값을 찾으려고 왼쪽으로 이동함. 피봇의 위치 교환이 일어나면 해당 피봇의 위치는 확정된다.

  ex)

  69 10 30 [2] 16 8 31 22

  L--->						<---R

  1. 우선 L은 2보다 크거나 같은 값을 찾아 오른쪽으로 이동하는데, 69를 바로 찾는다. R은 2보다 작은 값을 찾아 왼쪽으로 이동하는데, 2보다 작은 값을 찾지 못하고 끝까지 가서 L과 만난다.

  2. 이 경우(L과 R이 만남) 피봇이 가장 작은 값이 되므로 69와 피봇(2)을 교환해준다. 이 때 2는 위치가 확정된다. (더 이상 고려하지 않음)

     2 {10 30 69 16 8 31 22}

     

  3. 이제 2의 오른쪽 부분인 {10 30 69 16 8 31 22} 부분에 대해 퀵 정렬을 수행한다. 피봇은 가운데에 있는 16이 되고, 그 왼쪽과 오른쪽에서 각각 피봇보다 크거나 같은 값과 작은 값을 찾아 움직인다.

     10 30 69 [16] 8 31 22

      L--->                     <---R

  4. L은 30을 찾고(가장 먼저 찾은 것), R은 8을 찾는다. 그러면 이 둘을 교환해준다.

     10 8 69 [16] 30 31 22

  5. L과 R이 만나지 않는 한 같은 동작을 반복한다. 이제 다음을 확인해보면, L은 69를 찾고, R은 아무 값도 찾지 못한다. 이제 L과 R이 69에서 만나게 되고, 69와 피봇(16)을 교환해준다. 이 때 16의 위치는 확정된다.

      {10 8} [16] {69 30 31 22}

  6. 피봇의 양 옆에서 각각 퀵 정렬을 수행해준다.

      {[10] 8} [16] {69 30 31 22} -> {8} 10 16 {69 [30] 31 22}

     피봇인 10과 8을 교환하여 10의 위치가 확정된다. 8은 원소가 한 개 이므로 정렬을 수행하지 않는다.

     8 10 16 {22 [30] 31 69}

  7. 이제 모두 정렬이 된 것을 확인할 수 있는데, 컴퓨터는 모르니까 퀵 정렬을 계속 수행한다.

     그러면 L과 R이 각각 30보다 크거나 같은 값, 작은 값을 찾아 움직이는데, L은 30을 찾고, R은 값을 찾다가 30에서 L과 만나게 된다.

     L과 R이 만나면? L과 피봇의 자리 바꾸기 + 피봇의 위치 확정!

     8 10 16 {22} 30 {31 69}

  8. 22는 원소가 하나이므로 퀵정렬을 수행하지 않고, 31과 69는 퀵정렬을 다시 수행하여 L과 R이 31에서 만나게 된다.

     8 10 16 22 30 31 {69}

  9. 69는 원소가 하나이므로 더 이상 퀵 정렬을 수행하지 않는다!

```python
def quick_sort(a, begin, end):
    if begin < end:
        p = partition(a, begin, end)
        quick_sort(a, begin, p-1)
        quick_sort(a, p+1, end)

def partition(a, begin, end):
    pivot = (begin+end)//2
    L = begin
    R = end
    while L < R:
        while a[L] < a[pivot] and L<R:
            L += 1
        while a[R] >= a[pivot] and L<R:
            R -= 1
        if L < R:
            if L == pivot:
                pivot = R
            a[L], a[R] = a[R], a[L]
    a[pivot], a[R] = a[R], a[pivot]
    return R
seq = [69, 10, 30, 2, 16, 8, 31, 22]
quick_sort(seq, 0, 7)
print(seq)
```

